# 目录

[toc]

## 整型

- 使用`int`声明
- 输出/输入时使用`%d`匹配

## 浮点数

## 数组

```c
#include <stdio.h>
int main()
{
    int numbers[9];
    for (int i = 0; i <= 9; i++) {
        numbers[i] = i;
    }

    for (int i = 0; i <= 9; i++) {
        printf("%d\n", numbers[i]);
    }
    return 0;
}
```

数组是一种容器，其特点是

- 其中所有元素具有相同的数据类型
- 一旦创建，不能改变大小
  ~~只能用确定的数定义数组长度~~
  从 C99 开始可以在定义数组长度时使用变量
- 数组中的元素在内存中依次排列
- 数组`a[2]`可以出现在赋值的左边或右边
  例如`a[2]=a[1]+6`
- 数组的每个单元就是数组类型的一个变量
- `[]`中的数字叫做下标/索引,下标从 0 开始计数
  `a[2]`为数组`a`的第三个元素
- 编译器和运行环境都不会检测下标是否越界，不论是读还是写。
  一旦程序运行，越界的数组访问可能造成问题，导致程序崩溃 _(segmentation fault)_
  但也可能运气好，没造成严重后果
  程序员有责任来保证只使用有效的下标值：[0，数组的大小-1]
  ~~上面的代码示例就是一个越界得不是太明显的屑代码~~

## 函数

函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或**一个**值

![函数定义](foundation.assets/2021-09-05-22-49-53.webp)

```c
int isPrime(int i)
{
    int ret = 1;
    int k;
    for (k = 2; k < i - 1; k++) {
        if (i % k == 0) {
            ret = 0;
            break;
        }
    }
    return ret;
}
```

### 返回类型

- 一个函数里可以出现多个`return`语句，但最好还是遵循单一出口原则，不要整多个 `return`。
- 没有返回值的函数，返回类型设为`void`（就是上面图片中那样），这样的函数不能使用带值的`return`，也可以没有`return`；
  如果函数是有返回值的(返回类型不是`void`),必须使用带值的`return`。

### 函数的声明

- 被调用的函数需要写在调用它的地方在上面，因为 C 的编译器自上而下分析代码，编译器在读取到某个函数时必须要事先知道它，但把这些函数写在 main 前面的话不太美观，于是可以这样：

```c
#include <stdio.h>

void sum(int begin, int end); // 函数的原型声明，以分号结尾
int main()
{
    sum(1, 5); // 调用函数
    return 0;
}

void sum(int begin, int end) // 函数定义
{
    int i;
    int sum = 0;
    for (i = begin; i <= end; i++) {
        sum += i;
    }
    printf("%d到%d的和是%d\n", begin, end, sum);
}
```

- 原型声明的作用预先告诉编译器，`sum`是一个函数，在编译器分析到该函数定义部分时，还会再检查一遍声明和定义是否一致。

- 编译器只检查参数的类型，所以原型里可以不写参数的名字，但是一般都写上。

### 传值

- 调用函数时给的值与声明的参数类型可以不匹配，编译器会自动帮我们转换类型，但很可能它转换的结果不是我们所期望的。~~这是 C 语言传统上最大的漏洞，C 语言之后的语言在这方面都要比 C 严格~~

- 每个函数有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系。

```c
// 下面代码其实是无法达到目的的
// 原因见 “本地变量”
#include <stdio.h>

void swap(int a, int b);
int main()
{
    int x, y;
    scanf("%d %d", &x, &y);
    swap(x, y);
    printf("%d %d", x, y);
    return 0;
}

void swap(int a, int b)
{
    int t = a;
    a = b;
    b = t;
}
```

- 常常把声明与定义函数时的参数叫做形参，把调用函数时传入的参数叫做实参，这样容易让我等初学者混淆，其实他们之间就是**参数和值**的关系：我们在声明与定义函数时定义若干参数，在调用函数时传给它对应的若干个值；函数调用只做了一件事，那就是**传值**。~~和变量名无关~~

### 本地变量

- 又名局部变量、自动变量
- 函数每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量。
- 定义在函数内部的变量就是本地变量
- 参数也是本地变量。
- 变量的生存期(变量出现到消亡)和作用域(代码内可以访问该变量的范围)：大括号内(块)。

- 本地变量定义在块内
  - 它可以定义在函数的块内
  - 也可以定义在语句的块内
  - 甚至可以随便拉一对大括号来定义变量
  - 程序运行在这个块内前，其中的变量不存在，离开这个块，其中的变量就消失了。

```c
    { // 这也是个块
        int xxx = 666;
        printf("%d", xxx);
    }
```

- 块外面的定义在块里面仍然有效
- 如果在块内定义了和块外同名的变量，则掩盖外面的(仅在块内“圈地自萌”，出去块以后就会恢复原值)
- 不能在一个块内定义同名的变量
- 参数在进入函数时被初始化

### 其他

- 形似`void foo()`的声明表示不知道要传入哪种参数、几个参数
- 形似`void foo(void)`的声明表示该函数没有参数
- 调用函数时的圆括号里的逗号是标点符号不是运算符
  - `foo(a,b)` 逗号是标点符号，传入两个参数
  - `foo((a,b))` 传入了一个参数，逗号是运算符
- C 语言不允许函数嵌套定义
  - 可以在一个函数内声明另一个函数
  - 但不能在一个函数内定义另一个函数
- ~~可以在声明变量的同时声明函数(不推荐)~~
  - ~~`int i, j, sum(int a, int b);`~~
- ~~`return` 后面可以加圆括号，但没有任何意义，不要这样做~~
  - ~~`return(i);`~~
- 关于`main`
  - `main` 是我们写的程序的入口
  - `int main()` 也是一个函数

## 二维数组

```c
    int a[][5] = { // 初始化一个二维数组
        { 0, 1, 2, 3, 4 },
        { 2, 3, 4, 5, 6 },
    };
```

- 必须给出列数，行数可以由编译器来数
- 每行一个`{}`，用逗号分隔
- 最后一个逗号可带可不带，80 年代的计算机书上都让带，但现在时代变了
- 最后的逗号可以存在(如果省略，表示补零)
- 大括号也可以不写，但为了方便人阅读，还是写上为好
- 可以用定位

## 数组运算

- 数组的集成初始化

```c
int a[] = {2,3,4,5,6,7};
```

- 直接用大括号给出数组的所有元素的初始值
- 不需要给出数组的大小，编译器会自动数

```c
int a[10] = { [0] = 2, [2] = 3, 6 };
int b[10] = { 8 };
```

- 用[n]在初始化数据中给出定位
- 没有定位的数据接在前面的位置后面
- 其他位置的值补零
- 也可以不给出数组大小，让编译器算
- 特别适合初始数据稀疏的数组

```c
int d[10] = { 8 };
printf("%d\n", sizeof(d)); // 数组的大小
printf("%d\n", sizeof(d[0])); // 数组中第一个元素的大小
printf("%d\n", sizeof(d[2])); // 数组中第三个元素的大小
printf("%d\n", sizeof(d) / sizeof(d[0])); // 数组内元素数量
```

- `sizeof()`给出括号内变量所占据的内容的大小，单位是字节
- 相同数据类型的大小是恒定的

```c
int a[] = {2,3,4,5,6,7};
int b[] = a; // 错误做法！
```

- 数组变量本身不能被赋值
- 要把一个数组内的所有元素交给另一个数组，必须采用遍历

- 遍历数组通常使用`for`循环，让循环变量`i`从 0 到数组的长度，这样循环体内的 i 正好是数组最大的有效下标
- 常见错误：

  - 循环结束条件<=数组长度
  - 离开循环后，继续用`i`的值做数组元素的下标

- 数组作为函数参数时
  - 不能在[中给出数组的大小]
  - 不能再利用`sizeof`计算数组的元素个数

### 搜索

> 在一个数组中找到某个数的位置（或确认是否存在）

- 遍历
- 二分查找
  - 必须在有序数据中进行查找

### 排序初步

```c
#include <stdio.h>
int max(int a[], int len)
{
    int maxid = 0;
    for (int i = 0; i < len; i++) {
        if (a[i] > a[maxid]) {
            maxid = i;
        }
    }
    return maxid;
}

int main()
{
    int a[] = { 12, 34, 56, 78, 98, 76, 54, 32, 1 };
    int len = sizeof(a) / sizeof(a[0]);

    for (int i = len - 1; i > 0; i--) {
        int maxid = max(a, i + 1);
        // swap a[maxid],a[len-1]
        int t = a[maxid];
        a[maxid] = a[i];
        a[i] = t;
    }

    for (int i = 0; i < len; i++) {
        printf("%d ", a[i]);
    }

    return 0;
}
```

## 指针

### 运算符`&`

- `scanf(“%d”,&i);`里的`&`
- 它的作用是获得变量的地址，它的操作数必须是变量
  - `int i=0;printf("%x\n", &i);`
- 地址的大小是否与 int 相同取决于编译器(32 位的相同，64 位的不相同)

  - `int i=0;printf("%p\n", &i);`

- `&`不能对不是变量的东西取地址

### 指针

```c
int i;
int* p = &i; // *表示p是一个指针，指向的是一个int，

// 下面两行意思是一样的，
// 都表示p是一个指针，指向的是一个int，q都是一个普通的int类型变量
int* p,q;
int *p,q;
// * 并不是加给了“int”，而是加给了“p”
// “*p” 是一个int，于是p是一个指针
// 并没有“int *”这种类型
```

- 指针类型的变量，就是保存地址的变量
- 变量的值是内存的地址
  - 普通变量的值是实际的值
  - 指针变量的值是具有实际值的变量的地址

- `void f(int *p);`
  - 在被调用时得到了某个变量的地址
  - `int i=0;f(&i)`
  - 在函数里可以通过指针来访问外面这个i

```c
#include <stdio.h>

void f(int* p);
void g(int k);

int main(void)
{
    int i = 6;
    printf("&i=%p\n", &i); // 打印i的地址
    f(&i); // 把i的地址交给函数f()里的变量p
    g(i); // 把i的值交给函数g()里的变量k
    return 0;
}

void f(int* p)
{ // 在函数里可以通过指针来访问外面的i
    printf(" p=%p\n", p);
    printf("*p=%d\n", *p); // 这里 *p 作为一个整体时表示地址对应变量的值
    printf("sizeof(p)=%d\n", sizeof(p));
    printf("sizeof(*p)=%d\n", sizeof(*p));
    *p = 26; // 把地址为 p 的变量的值改为26
}

void g(int k)
{
    printf("k=%d\n", k);
}
```

- `*`是一个单目运算符，用来访问指针的值所表示的地址上的变量

  - 可以做左值也可以做右值

  - `int k = *p;`

    `*p = k+1;`

### 指针与数组

- 传入函数的数组
  - 函数参数表的数组实际上是一个指针

  - 但是可以用数组的运算符`[]`进行运算
  - 以下四种函数原型是等价的：
    - `int sum(int *ar,int n);`
    - `int sum(int *,int);`
    - `int sum(int ar[],int n);`
    - `int sum(int [],int);`

- 数组变量是特殊的指针，所以
  - `int a[10]; int* p=a;` // 无需用 & 取地址
  - `a == &a[0]` // 数组的单元表达的是变量，需要用&取地址

- `[ ]` 运算符可以对数组做，也可以对指针做
  - `p[0]`<==>`a[0]`
- `*`运算符可以对指针做，也可以对数组做
  - `*a=25`
- 数组变量是一个 const 的指针，所以不能被赋值
  - `int a[]` <==> `int * const a = ....`

![image-20210914234946662](foundation.assets/image-20210914234946662.png)